{
    "language": "Solidity",
    "sources": {
        "contracts/AoriVault.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { IAoriVault } from \"./interfaces/IAoriVault.sol\";\nimport { IAoriV2 } from \"aori-v2-contracts/src/interfaces/IAoriV2.sol\";\nimport { Instruction } from \"./interfaces/IBatchExecutor.sol\";\nimport { BatchExecutor } from \"./BatchExecutor.sol\";\n\ncontract AoriVault is IAoriVault, BatchExecutor {\n\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\n    \n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address public aoriProtocol;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        address _owner,\n        address _aoriProtocol\n    ) BatchExecutor(_owner) {\n        aoriProtocol = _aoriProtocol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool) {\n        if (hookData.length == 0) {\n            return true;\n        }\n\n        require(managers[tx.origin], \"Only a manager can force the execution of this trade\");\n        require(msg.sender == aoriProtocol, \"Only aoriProtocol can interact with this contract\");\n\n        (Instruction[] memory preSwapInstructions,) = abi.decode(hookData, (Instruction[], Instruction[]));\n        _execute(preSwapInstructions);\n        return true;\n    }\n\n    function afterAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool) {\n        if (hookData.length == 0) {\n            return true;\n        }\n\n        require(managers[tx.origin], \"Only a manager can force the execution of this trade\");\n        require(msg.sender == aoriProtocol, \"Only aoriProtocol can trade\");\n\n        (, Instruction[] memory postSwapInstructions) = abi.decode(hookData, (Instruction[], Instruction[]));\n        _execute(postSwapInstructions);\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                EIP-1271\n    //////////////////////////////////////////////////////////////*/\n\n    function isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4) {\n        require(_signature.length == 65);\n\n        // Deconstruct the signature into v, r, s\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        assembly {\n            // first 32 bytes, after the length prefix.\n            r := mload(add(_signature, 32))\n            // second 32 bytes.\n            s := mload(add(_signature, 64))\n            // final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(_signature, 96)))\n        }\n\n        address ethSignSigner = ecrecover(_hash, v, r, s);\n\n        // EIP1271 - dangerous if the eip151-eip1271 pairing can be found\n        address eip1271Signer = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    _hash\n                )\n            ), v, r, s);\n\n        // check if the signature comes from a valid manager\n        if (managers[ethSignSigner] || managers[eip1271Signer]) {\n            return ERC1271_MAGICVALUE;\n        }\n\n        return 0x0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                EIP-165\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 _interfaceId) public view returns (bool) {\n        return\n            (_interfaceId == IAoriVault.beforeAoriTrade.selector) ||\n            (_interfaceId == IAoriVault.afterAoriTrade.selector);\n    }\n}"
        },
        "contracts/interfaces/IAoriVault.sol": {
            "content": "pragma solidity 0.8.17;\n\nimport { IAoriV2 } from \"aori-v2-contracts/src/interfaces/IAoriV2.sol\";\nimport { IAoriHook } from \"aori-v2-contracts/src/interfaces/IAoriHook.sol\";\nimport { IERC1271 } from \"aori-v2-contracts/src/interfaces/IERC1271.sol\";\nimport { IERC165 } from \"aori-v2-contracts/src/interfaces/IERC165.sol\";\nimport { IBatchExecutor } from \"./IBatchExecutor.sol\";\n\ninterface IAoriVault is IERC1271, IERC165, IAoriHook, IBatchExecutor {\n    function beforeAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool);\n    function afterAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool);\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view returns (bytes4);\n}"
        },
        "lib/aori-v2-contracts/src/interfaces/IAoriV2.sol": {
            "content": "pragma solidity 0.8.17;\n\ninterface IAoriV2 {\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    struct Order {\n        address offerer;\n        address inputToken;\n        uint256 inputAmount;\n        uint256 inputChainId;\n        address inputZone;\n        address outputToken;\n        uint256 outputAmount;\n        uint256 outputChainId;\n        address outputZone;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 salt;\n        uint256 counter;\n        bool toWithdraw;\n    }\n\n    struct MatchingDetails {\n        Order makerOrder;\n        Order takerOrder;\n\n        bytes makerSignature;\n        bytes takerSignature;\n        uint256 blockDeadline;\n\n        // Seat details\n        uint256 seatNumber;\n        address seatHolder;\n        uint256 seatPercentOfFees;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OrdersSettled(\n        bytes32 indexed makerHash,\n        bytes32 indexed takerHash,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 matchingHash\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 SETTLE\n    //////////////////////////////////////////////////////////////*/\n\n    function settleOrders(MatchingDetails calldata matching, bytes calldata serverSignature, bytes calldata hookData, bytes calldata options) external payable;\n\n    /*//////////////////////////////////////////////////////////////\n                                DEPOSIT\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(address _account, address _token, uint256 _amount) external;\n\n    /*//////////////////////////////////////////////////////////////\n                                WITHDRAW\n    //////////////////////////////////////////////////////////////*/\n\n    function withdraw(address _token, uint256 _amount) external;\n\n    /*//////////////////////////////////////////////////////////////\n                               FLASHLOAN\n    //////////////////////////////////////////////////////////////*/\n\n    function flashLoan(address recipient, address token, uint256 amount, bytes memory userData, bool receiveToken) external;\n\n    /*//////////////////////////////////////////////////////////////\n                                 COUNTER\n    //////////////////////////////////////////////////////////////*/\n\n    function incrementCounter() external;\n    function getCounter() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                               TAKER FEE\n    //////////////////////////////////////////////////////////////*/\n\n    function setTakerFee(uint8 _takerFeeBips, address _takerFeeAddress) external;\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function hasOrderSettled(bytes32 orderHash) external view returns (bool settled);\n    function balanceOf(address _account, address _token) external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                            HELPER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function signatureIntoComponents(\n        bytes memory signature\n    ) external pure returns (\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    );\n    function getOrderHash(Order memory order) external view returns (bytes32 orderHash);\n    function getMatchingHash(MatchingDetails calldata matching) external view returns (bytes32 matchingHash);\n}"
        },
        "contracts/interfaces/IBatchExecutor.sol": {
            "content": "pragma solidity 0.8.17;\n\nstruct Instruction {\n    address to;\n    uint256 value;\n    bytes data;\n}\n\ninterface IBatchExecutor {\n    function execute(Instruction[] calldata instructions) external payable;\n    function withdrawAll(address token, address recipient) external;\n    function setManager(address _manager, bool _isManager) external;\n}"
        },
        "contracts/BatchExecutor.sol": {
            "content": "pragma solidity 0.8.17;\nimport {IBatchExecutor, Instruction } from \"./interfaces/IBatchExecutor.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\n\ncontract BatchExecutor is IBatchExecutor {\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    address internal owner;\n    mapping (address => bool) public managers;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Call(address to, uint256 value, bytes data);\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        address _owner\n    ) {\n        owner = _owner;\n\n        // Set owner as a manager\n        managers[_owner] = true;\n\n        // Set own contract as a manager\n        managers[address(this)] = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                EXECUTE\n    //////////////////////////////////////////////////////////////*/\n\n    function execute(\n        Instruction[] calldata instructions\n    ) public payable {\n        require(managers[msg.sender], \"Only a manager can execute\");\n        _execute(instructions);\n    }\n\n    function _execute(\n        Instruction[] memory instructions\n    ) internal {\n        uint256 length = instructions.length;\n        for (uint256 i; i < length; i++) {\n            address to = instructions[i].to;\n            uint256 value = instructions[i].value;\n            bytes memory _data = instructions[i].data;\n\n            // If call to external function is not successful, revert\n            (bool success, ) = to.call{value: value}(_data);\n            require(success, \"Call to external function failed\");\n            emit Call(to, value, _data);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              WITHDRAWALL\n    //////////////////////////////////////////////////////////////*/\n\n    function withdrawAll(address token, address recipient) public {\n        require(managers[msg.sender], \"Only owner or this contract can execute\");\n        IERC20(token).transfer(recipient, IERC20(token).balanceOf(address(this)));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    function setManager(address _manager, bool _isManager) external {\n        require(owner == msg.sender, \"Only owner can call this function\");\n        managers[_manager] = _isManager;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                  MISC\n    //////////////////////////////////////////////////////////////*/\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
        },
        "lib/aori-v2-contracts/src/interfaces/IAoriHook.sol": {
            "content": "pragma solidity 0.8.17;\n\nimport \"./IAoriV2.sol\";\n\ninterface IAoriHook {\n    function beforeAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool);\n    function afterAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool);\n}"
        },
        "lib/aori-v2-contracts/src/interfaces/IERC1271.sol": {
            "content": "pragma solidity 0.8.17;\n\ninterface IERC1271 {\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n  // bytes4 constant internal MAGICVALUE = 0x1626ba7e;\n\n  /**\n   * @dev Should return whether the signature provided is valid for the provided hash\n   * @param _hash      Hash of the data to be signed\n   * @param _signature Signature byte array associated with _hash\n   *\n   * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n   * MUST allow external calls\n   */ \n  function isValidSignature(\n    bytes32 _hash, \n    bytes memory _signature)\n    external\n    view \n    returns (bytes4 magicValue);\n}"
        },
        "lib/aori-v2-contracts/src/interfaces/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
        },
        "lib/forge-std/src/interfaces/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "LayerZero-v2/=lib/aori-v2-contracts/lib/LayerZero-v2/",
            "aori-v2-contracts/=lib/aori-v2-contracts/",
            "create3-factory/=lib/create3-factory/",
            "ds-test/=lib/ds-test/src/",
            "forge-std/=lib/forge-std/src/",
            "seaport-types/=lib/seaport-types/",
            "solmate/=lib/aori-v2-contracts/lib/solmate/src/"
        ],
        "optimizer": {
            "enabled": true,
            "runs": 1000000
        },
        "metadata": {
            "bytecodeHash": "ipfs"
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata"
                ]
            }
        },
        "evmVersion": "london",
        "viaIR": true,
        "libraries": {}
    }
}