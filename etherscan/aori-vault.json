{
    "language": "Solidity",
    "sources": {
        "contracts/AoriVault.sol": {
            "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\nimport { IAoriVault } from \"./interfaces/IAoriVault.sol\";\nimport { IAoriV2 } from \"aori-v2-contracts/src/interfaces/IAoriV2.sol\";\nimport { Instruction } from \"./interfaces/IBatchExecutor.sol\";\nimport { BatchExecutor } from \"./BatchExecutor.sol\";\n\ncontract AoriVault is IAoriVault, BatchExecutor {\n\n    // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n    bytes4 constant internal ERC1271_MAGICVALUE = 0x1626ba7e;\n    \n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    address private aoriProtocol;\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        address _owner,\n        address _aoriProtocol\n    ) BatchExecutor(_owner) {\n        aoriProtocol = _aoriProtocol;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 HOOKS\n    //////////////////////////////////////////////////////////////*/\n\n    function beforeAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool) {\n        if (hookData.length == 0) {\n            return true;\n        }\n\n        require(managers[tx.origin], \"Only a manager can force the execution of this trade\");\n        require(msg.sender == aoriProtocol, \"Only aoriProtocol can interact with this contract\");\n\n        (Instruction[] memory preSwapInstructions,) = abi.decode(hookData, (Instruction[], Instruction[]));\n        _execute(preSwapInstructions);\n        return true;\n    }\n\n    function afterAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool) {\n        if (hookData.length == 0) {\n            return true;\n        }\n\n        require(managers[tx.origin], \"Only a manager can force the execution of this trade\");\n        require(msg.sender == aoriProtocol, \"Only aoriProtocol can trade\");\n\n        (, Instruction[] memory postSwapInstructions) = abi.decode(hookData, (Instruction[], Instruction[]));\n        _execute(postSwapInstructions);\n        return true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                EIP-1271\n    //////////////////////////////////////////////////////////////*/\n\n    function isValidSignature(bytes32 _hash, bytes memory _signature) public view returns (bytes4) {\n        require(_signature.length == 65);\n\n        // Deconstruct the signature into v, r, s\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n        assembly {\n            // first 32 bytes, after the length prefix.\n            r := mload(add(_signature, 32))\n            // second 32 bytes.\n            s := mload(add(_signature, 64))\n            // final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(_signature, 96)))\n        }\n\n        address ethSignSigner = ecrecover(_hash, v, r, s);\n\n        // EIP1271 - dangerous if the eip151-eip1271 pairing can be found\n        address eip1271Signer = ecrecover(\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19Ethereum Signed Message:\\n32\",\n                    _hash\n                )\n            ), v, r, s);\n\n        // check if the signature comes from a valid manager\n        if (managers[ethSignSigner] || managers[eip1271Signer]) {\n            return ERC1271_MAGICVALUE;\n        }\n\n        return 0x0;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                EIP-165\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 _interfaceId) public view returns (bool) {\n        return\n            (_interfaceId == IAoriVault.beforeAoriTrade.selector) ||\n            (_interfaceId == IAoriVault.afterAoriTrade.selector);\n    }\n}"
        },
        "contracts/interfaces/IAoriVault.sol": {
            "content": "pragma solidity 0.8.17;\n\nimport { IAoriV2 } from \"aori-v2-contracts/src/interfaces/IAoriV2.sol\";\nimport { IAoriHook } from \"aori-v2-contracts/src/interfaces/IAoriHook.sol\";\nimport { IERC1271 } from \"aori-v2-contracts/src/interfaces/IERC1271.sol\";\nimport { IERC165 } from \"aori-v2-contracts/src/interfaces/IERC165.sol\";\nimport { IBatchExecutor } from \"./IBatchExecutor.sol\";\n\ninterface IAoriVault is IERC1271, IERC165, IAoriHook, IBatchExecutor {\n    function beforeAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool);\n    function afterAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool);\n    function isValidSignature(bytes32 _hash, bytes memory _signature) external view returns (bytes4);\n}"
        },
        "lib/aori-v2-contracts/src/interfaces/IAoriV2.sol": {
            "content": "pragma solidity 0.8.17;\n\ninterface IAoriV2 {\n\n    /*//////////////////////////////////////////////////////////////\n                                STRUCTS\n    //////////////////////////////////////////////////////////////*/\n\n    struct Order {\n        address offerer;\n        address inputToken;\n        uint256 inputAmount;\n        uint256 inputChainId;\n        address inputZone;\n        address outputToken;\n        uint256 outputAmount;\n        uint256 outputChainId;\n        address outputZone;\n        uint256 startTime;\n        uint256 endTime;\n        uint256 salt;\n        uint256 counter;\n        bool toWithdraw;\n    }\n\n    struct MatchingDetails {\n        Order makerOrder;\n        Order takerOrder;\n\n        bytes makerSignature;\n        bytes takerSignature;\n        uint256 blockDeadline;\n\n        // Seat details\n        uint256 seatNumber;\n        address seatHolder;\n        uint256 seatPercentOfFees;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event OrdersSettled(\n        bytes32 indexed makerHash,\n        bytes32 indexed takerHash,\n        address inputToken,\n        address outputToken,\n        uint256 inputAmount,\n        uint256 outputAmount,\n        bytes32 matchingHash\n    );\n\n    /*//////////////////////////////////////////////////////////////\n                                 SETTLE\n    //////////////////////////////////////////////////////////////*/\n\n    function settleOrders(MatchingDetails calldata matching, bytes calldata serverSignature, bytes calldata hookData, bytes calldata options) external payable;\n\n    /*//////////////////////////////////////////////////////////////\n                                DEPOSIT\n    //////////////////////////////////////////////////////////////*/\n\n    function deposit(address _account, address _token, uint256 _amount) external;\n\n    /*//////////////////////////////////////////////////////////////\n                                WITHDRAW\n    //////////////////////////////////////////////////////////////*/\n\n    function withdraw(address _token, uint256 _amount) external;\n\n    /*//////////////////////////////////////////////////////////////\n                               FLASHLOAN\n    //////////////////////////////////////////////////////////////*/\n\n    function flashLoan(address recipient, address token, uint256 amount, bytes memory userData, bool receiveToken) external;\n\n    /*//////////////////////////////////////////////////////////////\n                                 COUNTER\n    //////////////////////////////////////////////////////////////*/\n\n    function incrementCounter() external;\n    function getCounter() external view returns (uint256);\n\n    /*//////////////////////////////////////////////////////////////\n                               TAKER FEE\n    //////////////////////////////////////////////////////////////*/\n\n    function setTakerFee(uint8 _takerFeeBips, address _takerFeeAddress) external;\n\n    /*//////////////////////////////////////////////////////////////\n                             VIEW FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function hasOrderSettled(bytes32 orderHash) external view returns (bool settled);\n    function balanceOf(address _account, address _token) external view returns (uint256 balance);\n\n    /*//////////////////////////////////////////////////////////////\n                            HELPER FUNCTIONS\n    //////////////////////////////////////////////////////////////*/\n\n    function signatureIntoComponents(\n        bytes memory signature\n    ) external pure returns (\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    );\n    function getOrderHash(Order memory order) external view returns (bytes32 orderHash);\n    function getMatchingHash(MatchingDetails calldata matching) external view returns (bytes32 matchingHash);\n}"
        },
        "contracts/interfaces/IBatchExecutor.sol": {
            "content": "pragma solidity 0.8.17;\n\nstruct Instruction {\n    address to;\n    uint256 value;\n    bytes data;\n}\n\ninterface IBatchExecutor {\n    function execute(Instruction[] calldata instructions) external payable;\n    function withdrawAll(address token, address recipient) external;\n    function setManager(address _manager, bool _isManager) external;\n}"
        },
        "contracts/BatchExecutor.sol": {
            "content": "pragma solidity 0.8.17;\nimport {BalancerLoanReceiver} from \"./adapters/BalancerLoanReceiver.sol\";\nimport {IBatchExecutor, Instruction } from \"./interfaces/IBatchExecutor.sol\";\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\n\ncontract BatchExecutor is IBatchExecutor {\n\n    /*//////////////////////////////////////////////////////////////\n                                 STATE\n    //////////////////////////////////////////////////////////////*/\n\n    address internal owner;\n    mapping (address => bool) public managers;\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Call(address to, uint256 value, bytes data);\n\n    /*//////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(\n        address _owner\n    ) {\n        owner = _owner;\n\n        // Set owner as a manager\n        managers[_owner] = true;\n\n        // Set own contract as a manager\n        managers[address(this)] = true;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                EXECUTE\n    //////////////////////////////////////////////////////////////*/\n\n    function execute(\n        Instruction[] calldata instructions\n    ) public payable {\n        require(managers[msg.sender], \"Only a manager can execute\");\n        _execute(instructions);\n    }\n\n    function _execute(\n        Instruction[] memory instructions\n    ) internal {\n        uint256 length = instructions.length;\n        for (uint256 i; i < length; i++) {\n            address to = instructions[i].to;\n            uint256 value = instructions[i].value;\n            bytes memory _data = instructions[i].data;\n\n            // If call to external function is not successful, revert\n            (bool success, ) = to.call{value: value}(_data);\n            require(success, \"Call to external function failed\");\n            emit Call(to, value, _data);\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              WITHDRAWALL\n    //////////////////////////////////////////////////////////////*/\n\n    function withdrawAll(address token, address recipient) public {\n        require(managers[msg.sender], \"Only owner or this contract can execute\");\n        IERC20(token).transfer(recipient, IERC20(token).balanceOf(address(this)));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               MANAGEMENT\n    //////////////////////////////////////////////////////////////*/\n\n    function setManager(address _manager, bool _isManager) external {\n        require(owner == msg.sender, \"Only owner can call this function\");\n        managers[_manager] = _isManager;\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                  MISC\n    //////////////////////////////////////////////////////////////*/\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
        },
        "lib/aori-v2-contracts/src/interfaces/IAoriHook.sol": {
            "content": "pragma solidity 0.8.17;\n\nimport \"./IAoriV2.sol\";\n\ninterface IAoriHook {\n    function beforeAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool);\n    function afterAoriTrade(IAoriV2.MatchingDetails calldata matching, bytes calldata hookData) external returns (bool);\n}"
        },
        "lib/aori-v2-contracts/src/interfaces/IERC1271.sol": {
            "content": "pragma solidity 0.8.17;\n\ninterface IERC1271 {\n  // bytes4(keccak256(\"isValidSignature(bytes32,bytes)\")\n  // bytes4 constant internal MAGICVALUE = 0x1626ba7e;\n\n  /**\n   * @dev Should return whether the signature provided is valid for the provided hash\n   * @param _hash      Hash of the data to be signed\n   * @param _signature Signature byte array associated with _hash\n   *\n   * MUST return the bytes4 magic value 0x1626ba7e when function passes.\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\n   * MUST allow external calls\n   */ \n  function isValidSignature(\n    bytes32 _hash, \n    bytes memory _signature)\n    external\n    view \n    returns (bytes4 magicValue);\n}"
        },
        "lib/aori-v2-contracts/src/interfaces/IERC165.sol": {
            "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
        },
        "contracts/adapters/BalancerLoanReceiver.sol": {
            "content": "pragma solidity ^0.8.0;\n\nimport {IERC20} from \"forge-std/interfaces/IERC20.sol\";\n\n/// @notice Skinny interface for the Balancer Vault contract that provides the flash loaned tokens\ninterface IBalancer {\n    function flashLoan(\n        address recipient,\n        address[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory userData\n    ) external;\n}\n\n/// @title BalancerLoanReceiver\n/// @author Hilliam\n/// @notice Minimal implementation to receive a Balancer flash loan\nabstract contract BalancerLoanReceiver {\n    /*//////////////////////////////////////////////////////////////\n                               CONSTANTS\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Balancer Vault Contract\n    // address constant balancerAddress =\n    //     0xBA12222222228d8Ba445958a75a0704d566BF2C8;\n\n    /*//////////////////////////////////////////////////////////////\n                            STATE VARIABLES\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Flag for protecting the `receiveFlashLoan` callback\n    /// @dev `flashWallOn` is false only when a flash loan is about to be executed and turned on otherwise.\n    /// @dev See an example of unprotected callbacks: https://github.com/SunWeb3Sec/DeFiVulnLabs/blob/main/src/test/Unprotected-callback.sol\n    bool private flashWallOn = true;\n    address immutable balancerAddress;\n    IBalancer immutable balancer;\n\n    constructor(address _balancerAddress) {\n        balancerAddress = _balancerAddress;\n        balancer = IBalancer(_balancerAddress);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                               FLASH LOAN\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Flash loan `amount` of a single `token`\n    /// @param token Token address to flash loan\n    /// @param amount Amount of `token` to flash loan\n    /// @dev Simply packages up parameters to fit inside `flashLoanMultipleTokens` call\n    function _flashLoan(\n        address token,\n        uint256 amount,\n        bytes memory data\n    ) internal {\n        address[] memory tokens = new address[](1);\n        tokens[0] = token;\n\n        uint256[] memory amounts = new uint256[](1);\n        amounts[0] = amount;\n\n        _flashLoanMultipleTokens(tokens, amounts, data);\n    }\n\n    /// @notice Flash loan multiple `tokens`\n    /// @param tokens Array of token addresses to flash loan\n    /// @param amounts Array of corresponding token amounts to flash loan\n    /// @dev Tokens should be arranged in address order e.g [0x1, 0x3, 0xA, ...].\n    /// @dev See https://dev.balancer.fi/references/error-codes#input for more information.\n    function _flashLoanMultipleTokens(\n        address[] memory tokens,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal {\n        // Flag that we have turned off our `flashWall` to allow for a flash loan to occur\n        flashWallOn = false;\n        balancer.flashLoan(address(this), tokens, amounts, data);\n    }\n\n    /// @notice Callback function that is ran\n    /// @param tokens Array of tokens that have just been provided by flash loan\n    /// @param amounts Array of corresponding amounts that have just been provided\n    /// @dev The callback should be ran in the context that `msg.sender` == `balancerAddress`.\n    /// @dev `feeAmounts` is just an array of zeroes - Balancer offers free flash loans.\n    /// @dev `userData` is assumed to be unused for simplicity.\n    function receiveFlashLoan(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        uint256[] calldata /* feeAmounts */,\n        bytes calldata data\n    ) public {\n        // Ensure that the caller of this callback is Balancer\n        require(msg.sender == balancerAddress, \"Not Balancer\");\n\n        // Ensure that the flash wall is off\n        require(!flashWallOn, \"Flash wall is on\");\n\n        // Run any needed logic to run upon receipt of flash-loaned tokens\n        _flashLoanCallback(tokens, amounts, data);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            IERC20(tokens[i]).transfer(balancerAddress, amounts[i]);\n        }\n\n        // Turn back on flash wall to prevent others from calling this callback\n        flashWallOn = true;\n    }\n\n    /// @notice Internal logic for `receiveFlashLoan`\n    /// @param tokens Array of tokens that have just been provided by flash loan\n    /// @param amounts Array of corresponding amounts that have just been provided\n    function _flashLoanCallback(\n        IERC20[] calldata tokens,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) internal virtual;\n}\n"
        },
        "lib/forge-std/src/interfaces/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\n/// @dev Interface of the ERC20 standard as defined in the EIP.\n/// @dev This includes the optional name, symbol, and decimals metadata.\ninterface IERC20 {\n    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`\n    /// is the new allowance.\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /// @notice Returns the amount of tokens in existence.\n    function totalSupply() external view returns (uint256);\n\n    /// @notice Returns the amount of tokens owned by `account`.\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Moves `amount` tokens from the caller's account to `to`.\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the remaining number of tokens that `spender` is allowed\n    /// to spend on behalf of `owner`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\n    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.\n    /// `amount` is then deducted from the caller's allowance.\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    /// @notice Returns the name of the token.\n    function name() external view returns (string memory);\n\n    /// @notice Returns the symbol of the token.\n    function symbol() external view returns (string memory);\n\n    /// @notice Returns the decimals places of the token.\n    function decimals() external view returns (uint8);\n}\n"
        }
    },
    "settings": {
        "remappings": [
            "LayerZero-v2/=lib/aori-v2-contracts/lib/LayerZero-v2/",
            "aori-v2-contracts/=lib/aori-v2-contracts/",
            "create3-factory/=lib/create3-factory/",
            "ds-test/=lib/ds-test/src/",
            "forge-std/=lib/forge-std/src/",
            "seaport-types/=lib/seaport-types/",
            "solmate/=lib/aori-v2-contracts/lib/solmate/src/",
            "weird-erc20/=lib/aori-v2-contracts/lib/solmate/lib/weird-erc20/src/"
        ],
        "optimizer": {
            "enabled": true,
            "runs": 1000000
        },
        "metadata": {
            "bytecodeHash": "ipfs"
        },
        "outputSelection": {
            "*": {
                "": [
                    "ast"
                ],
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers",
                    "metadata"
                ]
            }
        },
        "evmVersion": "london",
        "viaIR": true,
        "libraries": {}
    }
}